---
title: "Python・VBA畑の自分が初めてRustを書いて感じたこと"
date: "2026-02-11"
excerpt: "所有権って何？借用って何？Python・VBA中心だった自分がRustに初挑戦して感じた難しさと、それでも「また書きたい」と思えた理由。"
tags: ["Rust", "プログラミング", "初心者", "個人開発"]
---

# Python・VBA畑の自分が初めてRustを書いて感じたこと

Excel Sheet Picのデスクトップアプリ版を作るために、初めてRustを書きました。

普段使っているのはPythonとVBA。型を意識することも少なく、動的に書いて動かして直す、というスタイルに慣れきっていました。

そんな自分がRustに飛び込んでみて、率直に感じたことをまとめます。

## Rustを選んだ経緯

デスクトップアプリを作るフレームワークとして **Tauri** を選びました。TauriのバックエンドはRust。つまり、Rustを避けては通れない。

詳しい開発の流れは別記事にまとめています。

→ [Excel Sheet PicをTauriでデスクトップアプリ化した話](/blog/excel-sheetpic-tauri-devlog)

## 最初の壁：所有権と借用

Rustで最初にぶつかる壁は、間違いなく**所有権（ownership）** です。

Pythonでは何も考えずに変数を渡せます。

```python
data = [1, 2, 3]
process(data)
print(data)  # 普通に使える
```

Rustでは、値を関数に渡すと**所有権が移動**します。

```rust
let data = vec![1, 2, 3];
process(data);
// println!("{:?}", data);  // エラー！もうdataは使えない
```

最初は「なんで使えないの？」と混乱しました。

解決策は**借用（borrowing）**。`&`をつけて「貸す」だけにすれば、元の変数も使い続けられます。

```rust
let data = vec![1, 2, 3];
process(&data);  // 借用（参照を渡す）
println!("{:?}", data);  // OK！
```

概念を理解するまでは苦しかったですが、「誰がこのデータの責任者か」を常に意識する設計は、コードの安全性を確実に高めていると感じました。

## コンパイラが厳しい、でもそれがいい

Rustのコンパイラは本当に厳しいです。

型が合わない、借用ルールに違反している、未使用の変数がある...。些細なことでもコンパイルを通してくれません。

最初はストレスでした。Pythonなら動かしてからエラーを直せばいいのに、と何度も思いました。

でも、途中から気づきました。

**コンパイルが通ったコードは、ほぼ確実に動く。**

Pythonだと「動いているつもりが、特定の入力で落ちる」ということがよくあります。Rustではそれがほとんどない。コンパイラが事前に問題を潰してくれるからです。

しかも、エラーメッセージが親切。「ここが問題です、こう直してみてください」と具体的に教えてくれます。慣れてくると、コンパイラとの対話がむしろ楽しくなってきました。

## Python・VBAとの違いで驚いたこと

### 型を明示する安心感

PythonやVBAでは型を省略できます。楽ですが、「この変数、何が入ってるんだっけ？」と迷うことも多い。

Rustでは型が明確です。関数の引数も戻り値も、何を受け取って何を返すかが一目でわかる。

```rust
fn load_sheets(path: &str) -> Vec<String> {
    // pathは文字列の参照、戻り値はStringのリスト
}
```

これは規模が大きくなるほど効いてくると感じました。

### エラー処理が強制される

Pythonでは`try/except`を書き忘れても動きます。Rustでは`Result`型で**エラー処理が強制**されます。

```rust
let file = File::open("data.xlsx")?;  // 失敗したらエラーを返す
```

面倒に感じる反面、「エラーを握りつぶして気づかないまま進む」ということが起きない。業務ツールを作る上で、これは大きな安心材料です。

### nullがない

Rustには`null`がありません。代わりに`Option`型で「値があるかもしれないし、ないかもしれない」を表現します。

```rust
let sheet_name: Option<String> = find_sheet("keyword");
match sheet_name {
    Some(name) => println!("見つかった: {}", name),
    None => println!("見つからなかった"),
}
```

Pythonの`None`チェック忘れでクラッシュ、という経験がある人には刺さる設計です。

## 難しかったこと

正直に書きます。

- **ライフタイム** - 借用がどこまで有効か。これは今でも完全には理解できていない
- **文字列型の多さ** - `String`と`&str`の使い分けに最初は混乱した
- **エラー型の変換** - 異なるエラー型をまとめて扱うのが面倒だった

でも、今回のようなTauriアプリ（Rustコマンドを3つ書く程度）なら、これらの難しさは最小限で済みました。

## 「また書きたい」と思えた理由

Rustは難しい。それは間違いない。

でも、書き終えたあとの**安心感**が全然違います。

- コンパイルが通れば実行時エラーはほぼない
- メモリ管理をランタイムに任せないから、パフォーマンスが安定
- 型とエラー処理が厳密だから、数ヶ月後に読んでも意図がわかる

Python・VBAは「速く書ける」、Rustは「安心して動かせる」。

業務ツールのバックエンドのように、**確実に動いてほしい部分**にはRustが向いていると感じました。次に何かローカルで動くツールを作るときも、Tauriを使うと思います。

## まとめ

| 観点 | Python / VBA | Rust |
|------|-------------|------|
| 学習コスト | 低い | 高い |
| 実行時エラー | 起きやすい | ほぼない |
| 型安全性 | 弱い | 強い |
| エラー処理 | 任意 | 強制 |
| 書く速さ | 速い | 遅い（最初は） |
| 動かす安心感 | 普通 | 高い |

初めてのRustは戸惑いの連続でしたが、「コンパイルが通れば動く」という体験は新鮮でした。

Tauriのおかげで、UIはいつものWeb技術で書きつつ、バックエンドだけRustに挑戦する、という入り方ができたのも大きかったです。

Rustが気になっているけど踏み出せない方には、Tauriアプリ開発から入るのをおすすめします。Rustを書く量が限定的なので、無理なく始められます。

→ 実際のTauriアプリ開発の流れは [こちらの記事](/blog/excel-sheetpic-tauri-devlog) にまとめています。
